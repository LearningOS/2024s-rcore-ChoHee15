# chapter3

## 一、功能

由于内核不能直接访问应用程序的地址空间，所以向应用给的指针写数据需要一轮查页表操作。这样可以使sys_get_time 和 sys_task_info正常工作。
对于mmap，它会先检测当前程序地址空间内是否有重合的逻辑段，然后添加新的逻辑段。
对于munmap，它会尝试搜索包含给定range的逻辑段，然后将此逻辑段删除。

//TODO
对于munmap指定一个逻辑段真子集的情况，是否应该仅删除一部分而不是整段删除？这会要求应用程序严格管理映射的内存




## 二、问答题

### 1. SV39 页表页表项

V：页表项是否合法
R/W/X：页面是否允许读/写/执行
U：页面是否允许用户态访问
G：是否为全局映射
A：自上一次被清零后，页面是否被访问过
D：自上一次被清零后，页面是否被修改过
RSW：保留为上层软件使用
Reserved：保留为后续使用

### 2. 缺页

1. 请问哪些异常可能是缺页导致的？//TODO

2. 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。//TODO

3. 采用Lazy策略，减少程序首次运行的加载开销，启动更快。后续使用中也仅加载需要使用的内存，可以减少内存消耗，提高利用率。

4. 处理10GB的连续内存页面，大概需要的页表项大小为``4KB * ( 10GB/2MB + 10GB/1GB + 1)``。

5. 若要实现Lazy策略，则在mmap时不直接alloc所有页面，而是根据使用情况分配页面；当缺页发生时调用alloc分配并修改映射信息。

6. 内存页面被swap到磁盘上导致的页面失效，在PTE上表现为存在位为0。

### 3. 双页表与单页表

1. 在单页表情况下，在获取到要调度程序的页表位置后即可设置satp寄存器。

2. 将内核相关页表项设置为不可用户态访问，即可控制用户态无法访问内核页面。

3. 单页表在切换地址空间时较为简单，不设置跳板也可以进行。其次内核代码访问用户的地址时不用手动查表，使编程较为简单。

4. 双页表实现下，进出内核时需要更换页表；此项目中通过设置跳板，使应用程序地址空间也可以访问部分内核的数据（trap的代码）。若我实现一个单页表操作系统，我会选择在``trap_handler``前将页表信息保存到上下文、在``trap_handler``后更换页表。






## 三、感受与建议

### 1.测试框架

如果能方便的选择某个测试运行就好了，当必须运行一套测试又涉及任务切换时，输出会显得比较乱









# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与**以下各位**就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 群友：麻了
> 我：mmap要记录到地址空间吗，还是只要塞页表里就好了
> 对方：感觉需要记录

2. 此外，我也参考了**以下资料**，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> chatgpt: 迭代器访问的区间是左闭右开还是左闭右闭？

1. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

2. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

